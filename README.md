# КПО ДЗ 3
- Матусевич Дмитрий Сергеевич
- БПИ243

Простая микросервисная система.
Написана на Spring Boot, использует PostgreSQL для данных и Docker для запуска.

## Функционал

1.  **Загрузка работ**:
    *   Принимаются файлы исходного кода: `.java`, `.cpp`, `.cs`, `.py`, `.kt`, а также `.txt`, `.md`, `.tex`.
    *   Ограничение по размеру: **100 КБ** (защита от "мусора").
    *   Метаданные (имя студента, название задачи) сохраняются в базу.

2.  **Анализ**:
    *   Сравнивает загруженную работу с другими работами **по той же задаче**.
    *   Если имена студентов разные, а **содержимое файлов совпадает один-в-один** — фиксируется плагиат (100%) - здесь самая примитивная система сравнения, так как суть дз вроде не в ней.
    *   Результат проверки сохраняется.

3.  **Визуализация (Word Cloud)**:
    *   Генерирует облако слов из текста работы.
    *   Использует внешний API (QuickChart.io).
    *   Доступно по адресу: `GET /reports/word-cloud/{id}` (возвращает PNG).

## Технологии
*   **Java 17**, **Spring Boot 3**
*   **PostgreSQL 15** (в Docker контейнере)
*   **Docker & Docker Compose**
*   **Gradle**

## Архитектура системы
Система состоит из трех микросервисов, работающих в единой сети Docker.

1.  **API Gateway** (`port: 8080`)
    *   Единая точка входа.
    *   Маршрутизирует запросы:
        *   `/works/**` -> **File Storing Service**.
        *   `/reports/**`, `/analyze/**` -> **File Analysis Service**.

2.  **File Storing Service** (`port: 8081`)
    *   **Ответственность**: Хранение файлов и метаданных.
    *   **База данных**: PostgreSQL (хранит имя студента, задачу, путь к файлу).
    *   **Файловая система**: Сохраняет сами файлы в папку `uploads/`.
    *   **Валидация**: Проверяет расширения и размер файлов.

3.  **File Analysis Service** (`port: 8082`)
    *   **Ответственность**: Бизнес-логика проверки на плагиат.
    *   **Взаимодействие**: Обращается к *Storing Service* (через HTTP/Feign) чтобы скачать содержимое файлов.
    *   **База данных**: PostgreSQL (хранит результаты проверок — отчеты).
    *   **Внешние API**: Интеграция с QuickChart.io для генерации облака слов.

---

## Сценарии взаимодействия (User Scenarios)

### Сценарий 1: Загрузка работы
1.  **Клиент** отправляет `POST /works` (файл + метаданные) на Gateway.
2.  **Gateway** пересылает запрос в *Storing Service*.
3.  **Storing Service**:
    *   Проверяет формат и размер файла.
    *   Сохраняет файл на диск.
    *   Записывает данные в БД.
    *   Возвращает ID работы (например, `UUID`).

### Сценарий 2: Проверка на плагиат
1.  **Клиент** отправляет `POST /analyze/{id}` на Gateway.
2.  **Gateway** пересылает запрос в *Analysis Service*.
3.  **Analysis Service**:
    *   Запрашивает метаданные работы у *Storing Service* (`GET /works/{id}`).
    *   Запрашивает список всех работ по той же "Задаче" (`GET /works?taskName=...`).
    *   **Цикл**: Для каждой работы скачивает её контент (`GET /works/{id}/file`) из *Storing Service*.
    *   Сравнивает байты. При совпадении проверяет дату сдачи (виноват тот, кто сдал позже).
    *   Сохраняет результат (`Report`) в свою БД.
4.  Возвращает отчет клиенту.

### Сценарий 3: Визуализация (Word Cloud)
1.  **Клиент** запрашивает картинку `GET /analysis/word-cloud/{id}`.
2.  **Analysis Service**:
    *   Скачивает файл работы из *Storing Service*.
    *   Извлекает текст.
    *   Отправляет текст в **QuickChart.io API**.
3.  **QuickChart** возвращает PNG-изображение.
4.  Сервис отдает картинку клиенту.

## Запуск

### Перед первым запуском
Если пересобираете проект или меняете настройки базы, лучше очистить старые данные:
```bash
docker compose down -v
```

### Основной вариант (Docker)
Самый простой способ. Всё соберется и запустится само.
```bash
docker compose up -d --build
```
*Нужно подождать пару минут, пока скачаются образы и Gradle.*

### Вариант 2: Запуск с pre-built JAR (быстрее)
Если не хотите ждать сборку внутри Docker. Требует локальной **Java 17+.**

1.  **Соберите JAR файлы локально**:
    ```bash
    ./gradlew build -x test
    ```
    *(На Windows используйте `gradlew.bat`, ну я использовал, хотя и обычный должен работать)*

2.  **Запустите prod-конфигурацию**:
    ```bash
    docker compose -f docker-compose.prod.yml up -d --build
    ```
    В этом режиме Docker просто берет готовые jar-файлы из папки `build/libs` и упаковывает их, что гораздо быстрее.

### Swagger UI (Документация)
После запуска интерфейс доступен по адресу:
**[http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html)**

> **Важно!**
> В правом верхнем углу в поле **Select a definition** можно переключаться между сервисами:
> *   `file-storing-service` — загрузка файлов.
> *   `file-analysis-service` — запуск проверки и получение отчетов.
